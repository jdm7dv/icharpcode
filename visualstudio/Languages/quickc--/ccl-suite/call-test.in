#!PERL_LOCATION
# -*- perl -*-

###############################################################################
#
# Copyright (c) 1995 by Mark Bailey.
#
# This code is distributed WITHOUT ANY WARRANTY. No claims are made as to
# whether it serves any particular purpose or even works at all.
#
###############################################################################

###############################################################################
#
# File: call-test
#
# Author: Mark Bailey
#
# Created: 11/29/95
#
# Description:
#
#      This runs a test suite of programs that are generated by the tgen
# test case generator. Configuration information about the compilers to 
# be tested is found in the $Test_Settings_File (typically test.settings).
#
# RCS Header:
#	$Header$
#
# Change Log:
#	$Log$
#	Revision 1.1  2001-11-05 18:32:40  nr
#	ccl stuff
#	
#	Revision 1.1  1995/12/05 19:29:18  mwb5y
#	Initial revision
#
#
###############################################################################

require "getopts.pl";

chop($Working_Dir=`ksh -c pwd`);
$Tgen_Command = "$Working_Dir/tgen -t";
$Test_Settings_File = "test.settings";		# Test configuration file
$Checkpoint_Frequency = 20;			# Frequency that test report
						# is generated
$Report_Filename = "test_report";		# Test report filename
#$Remote_Shell_Command = "rsh";			# Remote shell command
$Remote_Shell_Command = "";			# Remote shell command

$Version = "1.0";				# Program version number
$Host = "univac";				# Default Icon-aware server
$Target = "vax";				# Default target to test
$Ref = "cc";					# Default reference compiler
$Reference_CC_name = "cc";			# Default reference name
$Link_Command = "cc";				# Default linker command
@Compilers = ();				# Default list of compilers
$Total_Tests_Passed = 0;
$Total_Tests_Failed = 0;
$Total_Tests = 0;


&main();
exit(0);

sub main {
    local ($logfile);

    # Process command line arguments

    &Process_Switches();

    select(STDOUT); $| = 1;			# Turn off buffered I/O.

    if ($opt_V) {
	print "Version $Version\n";
	exit 0;
    }

    &get_test_settings();			# Read the test configuration

    if ($opt_n) {
	open($Progress, ">/dev/null");
    }
    else {
	$Progress = STDOUT;
    }

    print $Progress "Start time: ";
    if (!$opt_n) {
	&command("date");
    }

    $logfile = &unique_name("$Target.out");
    $Report_Filename = &unique_name($Report_Filename);
    print $Progress "Using $Report_Filename as file for test report\n";

    if ($opt_f) {
	&perform_single_test($opt_f);
	exit(0);
    }

    if ($opt_F) {
	&fork_process($logfile);

	# parent

	# Wait until the child quits. Then we know the grand-child has started up.

	wait;

	# Continually show what is going on.

	exec ("tail -f $logfile");
    }
    else {
	&child_process($logfile);
    }
}

###############################################################################
#
# Functions
#
###############################################################################

####
#
# NAME:     Process_Switches
#   
# PURPOSE:  Process command line switches.
#   
# ARGS:     <none>
#   
####


sub Process_Switches {

    # Valid switches:
    #
    # -V	- Show version number.
    # -f name	- Exercise single test case called <name>.
    # -s name	- Start test case generation at <name> (Skip previous ones).
    # -v 	- Generate varargs versions.
    # -F	- Fork process and tail output file.
    # 

    &Getopts('FVnvq:s:f:x:S:') ||
	die "Usage: call-test [-s start string][-q quick string][-f <single file test>\n";

    if ($opt_s) {
	$Tgen_Command = $Tgen_Command . " -s \"$opt_s\"";
    }

    if ($opt_v) {
	$Tgen_Command = $Tgen_Command . " -v";
    }

    if ($opt_q) {
	$Tgen_Command = $Tgen_Command . " -q \"$opt_q\"";
    }
}

####
#
# NAME:     fork_process
#   
# PURPOSE:  Cleanly forks a process to run tests. Changes process group
#           so parent's signals are not propogated to child.
#   
# ARGS:     Output filename.
#   
####

sub fork_process {
    local ($output) = @_;

    open(LOGFILE, ">$output") ||
	die "Couldn't open logfile $file: $!\n";
    # Spawn off a child process for running the test exerciser. This leaves us
    # free to show the output, or quit.

    unless (fork) { # child
	unless (fork) { # grand-child
	    setpgrp(0, $$);			# Change the process group to 
	    					# separate us from parent sigs
	    sleep 1 until getppid == 1;
	    print $Progress "Redirecting standard output to $logfile\n";
	    &redirect_output(LOGFILE);		# Send all output to logfile
	    &child_process($output);
	    exit 0;
	}
	exit 0;
    }
}

sub child_process {
    local ($output) = @_;

    &run_tests();			# Run the tests
    print $Progress "End time: ";
    &command("date");
}

####
#
# NAME:     run_tests   
#   
# PURPOSE:  Runs complete test suite, generates the error report.
#   
# ARGS:     <none>
#   
####

sub run_tests {
    local ($in, $out, $command);

    if ($Remote_Shell_Command) {
	$command = "$Remote_Shell_Command $Host 'cd $Working_Dir;" . 
	    " $Tgen_Command $Target.ctab'";
    }
    else {
	$command = "$Tgen_Command $Target.ctab";
    }
#    $command = "$Tgen_Command $Target.h";
#    print "Going to execute $command\n";
    ($in, $out) = &rw_popen($command);
    &perform_tests($in, $out);

    &generate_all_error_reports();
}

####
#
# NAME:     get_test_settings   
#   
# PURPOSE:  Opens the test settings file and parses its contents
#   
# ARGS:     <none>
#   
# RETURNS:  <none>
#   
# NOTES:    Values for $Host, $Target, $Ref, $Reference_CC_name
#	    and @Compilers are set.
#   
####

sub get_test_settings {

    open(SETTINGS, "<" . $Test_Settings_File) || 
	die "Couldn't open test.settings: $!\n";

    while (<SETTINGS>) {		# For each line in the file...
	chop;
	if (/^\s*$/) {			# Skip blank lines
	    next;
	}
	if (/^#/) {			# Skip comments (starting with #)
	    next;
	}
	if (/^Host\s+(.*)/i) {		# Host <hostname>
	    $Host = $1;
	}
	elsif (/^Target\s+(.*)/i) {	# Target <targetname>
	    $Target = $1;
	}
	elsif (/^Ref\s+(.*)/i) {	# Ref <ref. compiler name>
	    $Ref = $1;
	    $Reference_CC_name = &basename($1);
	}
	elsif (/^CC[1-9]*\s+(.*)/i) {	# CC[n] <compiler line>
	    push(@Compilers, $1);
	}
	else {
	    die "Unrecognized setting in $Test_Settings_File file:\n$_\n";
	}
    }
}

####
# 
# NAME:     perform_single_test
#   
# PURPOSE:  Exercises a test
#   
# ARGS:     <none>
#   
####

sub perform_single_test {
    local ($filename) = @_;

    if (!( -f "$filename.a.c" && -f "$filename.a.c")) {
	if ($Remote_Shell_Command) {
	    &command("$Remote_Shell_Command $Host 'cd $Working_Dir; $Tgen_Command -f $filename'");
	}
	else {
	    &command("$Tgen_Command -f $filename");
	}
    }
    print $Progress "$filename...";
    &test_file($filename);			# Test the file
    &generate_all_error_reports();
}

####
# 
# NAME:     perform_tests
#   
# PURPOSE:  Cycles through all of the test files found on the $in fd.
#   
# ARGS:     in - the reading fd connected to the test generation process
#           out - the writing fd connected to the test generation process
#   
####

sub perform_tests {
    local($in, $out) = @_;
    local($count);

    $count = 0;
    while ($file = <$in>) {			# For each test name...
	chop($file);
	print $Progress "$file...";
	if ($opt_S && ($file =~ /$opt_S/)) {
	    print $Progress "matches skip pattern, skipping...\n";
	    unlink (<*$file.[ab].c>);
	    print $out "\n";			# Send ack that we can go on
	    next;
	}

	&test_file($file);			# Test the file
	print $out "\n";			# Send ack that we can go on
	$count++;

	# Checkpoint and error report if necessary

	if ($count >= $Checkpoint_Frequency) {
	    print $Progress "Checkpointing test report: ";
	    &command("date");
	    &generate_all_error_reports($Report_Filename);
	    print $Progress "Done checkpointing: ";
	    &command("date");
	    $count = 0;
	}
    }
    print $Progress "done\n";
}

####
# 
# NAME:     test_file
#   
# PURPOSE:  Runs tests on a single test case.
#   
# ARGS:     file - the basename for the test case.
#   
# RETURNS:  
#   
# NOTES:    
#   
####

sub test_file {
    local ($file) = @_;
    local ($cc, $suffix, $source, $cc_name, $object);
    local ($once, $pass, $errfile, $worked, $passes);
    local (@compilers_worked, $a_cc, $b_cc);
    local (@external_caller, @external_callee, @internal);
    local (@linked_ok);

    # pass records the result of running the test. If it fails at any time
    # pass is set to 0.

    $pass = 1;

    # For each compiler, compile the part A and part B files for the test case

    foreach $cc ($Ref, @Compilers) {
	$cc_name = &basename($cc);
	print $Progress " $cc_name ";
	$worked = 1;
	foreach $suffix ("a", "b") {
	    print $Progress $suffix;
	    $source = "$file.$suffix.c";
	    $object = "$file.$suffix.o";
#	    $errfile = "$cc_name-$file.$suffix.errors";
	    $errfile = "/dev/null";

	    # Run the compile command, check the result

	    if (&command($cc, "-c", $source, "> $errfile 2>&1")) {
		print $Progress "*";
		&register_error($cc, $file, "Compilation error for .$suffix " .
				"version");
		$pass=0;
		$worked = 0;
		next;
	    }

	    # If an object file was generated, rename it to a compiler-specific
	    # name so the next compiler doesn't squash it.

	    if ( -e $object) {
		rename ($object, "$cc_name-$object");
	    }
	    else {
		print $Progress "*";
		&register_error($cc, $file, "Compiler generated no object " .
				"file for .$suffix version");
		$pass=0;
		$worked = 0;
	    }
	}
	if ($worked && $cc ne $Ref) {
	    push(@compilers_worked, $cc);
	}
    }

    # Link and run each CUT's (and REF's) caller with its callee

    foreach $cc ($Ref, @compilers_worked) {
	$internal{$cc} = &link_and_run($cc, $cc);
	if ($internal{$cc} == 0) {
	    $pass = 0;
	}
    }

    # Link and run each CUT's callee with the REF's caller

    foreach $cc (@compilers_worked) {
	$external_caller{$cc} = &link_and_run($cc, $Ref);
	if ($external_caller{$cc} == 0) {
	    $pass = 0;
	}
    }

    # Determine if we need to do anymore runs...

    foreach $cc (@compilers_worked) {

	# Count the number of cases that passed. There are two internal
	# cases (one for the REF, and one for the CUT)

	$passes = $internal{$Ref} + $internal{$cc} +
	    $external_caller{$cc};

	# If all the tests passed, we are all done. The external case passes.

	if ($passes == 3) {
	    $external_callee{$cc} = 1;
	}

	# If two of the cases pass, there must be an external error

	elsif ($passes == 2) {
	    $external_callee{$cc} = 0;
	    $pass = 0;
	}

	# Otherwise, we don't have enough information to diagnose the problem.
	# Do the final link and run with the REF's callee and the CUT's caller

	else {
	    $external_callee{$cc} = &link_and_run($Ref, $cc);

	    if ($external_callee{$cc} == 0) {
		$pass = 0;
	    }
	}
    }	

    # If no CUT successfully compiled the code, we can't tell much.
    # We can only report about the reference compiler (which hopefully worked).
    
    if ($#compilers_worked < 0) {
	if ($internal{$Ref} != 0) {
	    &register_error($Ref, $file, "Internally inconsistent, unable to diagnose");
	}
    }

    # For each of the CUT's...

    foreach $cc (@compilers_worked) {

	# Determine the error number for this compiler. This is a number
	# between 0 and 15, where:
	#
	# bit 0 = 1 if the CUT's caller can call its callee.
	# bit 1 = 1 if the CUT's caller can call the REF's callee.
	# bit 2 = 1 if the REF's callee can call the CUT's caller.
	# bit 3 = 1 if the CUT's caller can call its callee.

	$errno = ($internal{$Ref} ? 1 : 0) << 1;
	$errno = ($errno | ($external_callee{$cc} ? 1 : 0)) << 1;
	$errno = ($errno | ($external_caller{$cc} ? 1 : 0)) << 1;
	$errno |= $internal{$cc} ? 1 : 0;

	# Based on the value of the error number, register the appropriate
	# error and diagnosis.

	#
	# Case: Nothing works for anyone. We know nothing.
	#
	# 0 0
	# 0 0 (0)
	if ($errno == 0) {
	    &register_error($cc, $file, "Internally and externally inconsistent (as is reference compiler)");
	    &register_error($Ref, $file, "Internally and externally inconsistent (as is compiler-under-test)");
	}
	#
	# Case: CUT is internally consistent. REF is messed up.
	#
	# 0 0
	# 0 1 (1)
	elsif ($errno == 1) {
	    &register_error($Ref, $file, "Internally inconsistent and externally inconsistent with compiler-under-test");
	}
	#
	# Case: CUT's callee and REF's caller are messed up.
	#
	# 0 0
	# 1 0 (2)
	elsif ($errno == 2) {
	    &register_error($cc, $file, "Callee implementation error");
	    &register_error($Ref, $file, "Caller implementation error");
	}
	#
	# Case: CUT is internally consistent. REF's caller is messed up.
	#
	# 0 0
	# 1 1 (3)
	elsif ($errno == 3) {
	    &register_error($Ref, $file, "Caller implementation error");
	}
	#
	# Case: CUT's caller and REF's callee are messed up.
	#
	# 0 1
	# 0 0 (4)
	elsif ($errno == 4) {
	    &register_error($Ref, $file, "Callee implementation error");
	    &register_error($cc, $file, "Caller implementation error");
	}
	#
	# Case: CUT is internally consistent. REF's callee is messed up.
	#
	# 0 1
	# 0 1 (5)
	elsif ($errno == 5) {
	    &register_error($Ref, $file, "Callee implementation error");
	}
	#
	# Case: CUT and REF are externally consistent, but internally
	#       inconsistent. It is unclear what the problem here is--and this
	#       is unlikely to occur.
	#
	# 0 1
	# 1 0 (6)
	elsif ($errno == 6) {
	    &register_error($cc, $file, "Internally inconsistent, unable to diagnose");
	    &register_error($Ref, $file, "Internally inconsistent, unable to diagnose");
	}
	#
	# Case: This case would indicate that the transitive nature of 
	#       procedure call does not appear to be true. Flag as a problem.
	#
	# 0 1
	# 1 1 (7)
	elsif ($errno == 7) {
	    &register_error($cc, $file, "Error in script, impossible condition #7");
		&register_error($Ref, $file, "Error in script, impossible condition #7");
	}	
	#
	# Case: REF is internally consistent. CUT is messed up.
	#
	# 1 0
	# 0 0 (8)
	elsif ($errno == 8) {
	    &register_error($cc, $file, "Internally inconsistent and externally inconsistent with reference compiler");
	}
	#
	# Case: REF and CUT are internally consistent. CUT does not conform.
	#
	# 1 0
	# 0 1 (9)
	elsif ($errno == 9) {
	    &register_error($cc, $file, "Implements non-conforming convention");
	}
	#
	# Case: REF is internally consistent. CUT's callee is messed up.
	#
	# 0 1
	# 0 1 (10)
	elsif ($errno == 10) {
	    &register_error($cc, $file, "Callee implementation error");
	}
	#
	# Case: This case would indicate that the transitive nature of 
	#       procedure call does not appear to be true. Flag as a problem.
	#
	# 1 0
	# 1 1 (11)
	elsif ($errno == 11) {
	    &register_error($cc, $file, "Error in script, impossible condition #11");
		&register_error($Ref, $file, "Error in script, impossible condition #11");
	}
	#
	# Case: REF is internally consistent. CUT's caller is messed up.
	#
	# 1 1
	# 0 0 (12)
	elsif ($errno == 12) {
	    &register_error($cc, $file, "Caller implementation error");
	}
	#
	# Case: This case would indicate that the transitive nature of 
	#       procedure call does not appear to be true. Flag as a problem.
	#
	# 1 1
	# 0 1 (13)
	elsif ($errno == 13) {
	    &register_error($cc, $file, "Error in script, impossible condition #13");
		&register_error($Ref, $file, "Error in script, impossible condition #13");
	}
	#
	# Case: This case would indicate that the transitive nature of 
	#       procedure call does not appear to be true. Flag as a problem.
	#
	# 1 1
	# 1 0 (14)
	elsif ($errno == 14) {
	    &register_error($cc, $file, "Error in script, impossible condition #14");
		&register_error($Ref, $file, "Error in script, impossible condition #14");
	}
	#
	# Case: All combinations worked. Everything is fine.
	#       
	# 1 1
	# 1 1 (15)
	elsif ($errno == 15) {
	    # all ok.
	}
	else {
	    &register_error($Ref, $file, "Error in script, impossible condition #" . $errno);
	    &register_error($cc, $file, "Error in script, impossible condition #" . $errno);
	}
    }
    # Keep a count of the number of tests passed, failed and total.

    $Total_Tests++;
    if ($pass) {
	$Total_Tests_Passed++;
	print $Progress "...passed\n";

    }
    else {
	$Total_Tests_Failed++;
	print $Progress "...failed\n";
    }

    # delete the source files and the empty errors file

#    unlink (<*$file.[ab].c>) unless ($opt_f);
#    # Delete the object and executable files. Leave the .c and errors files
#    # if the file didn't pass.

#    foreach $errfile (<*$file.errors *$file.[ab].errors>) {
#	if (-z "$errfile") {
#	unlink ("$errfile") unless ($opt_f);
#
##	}
#
#    }
    unlink (<core *$file.errors *$file.[ab].errors>);
    unlink (<*$file*.o *$file.out>);
    unlink (<*$file*.c>) unless ($opt_f);
}

sub link_and_run {
    local($a_cc, $b_cc) = @_;
    local($a_cc_name, $b_cc_name, $pass);
    local($executable, $errfile, $Link_Command);

    $pass = 1;

    $a_cc_name = &basename($a_cc);
    $b_cc_name = &basename($b_cc);

    print $Progress " ($a_cc_name,$b_cc_name) L";
    $executable = "$a_cc_name-$b_cc_name-$file.out";
#    $errfile = "link-$file.errors";
    $errfile = "/dev/null";

    # Link the part A and B compilers. If both parts are generated by the
    # same compiler, use that compiler to link. Otherwise, use the Reference
    # compiler.

    $Link_Command = $b_cc eq $a_cc ? $a_cc : $Ref;
    
    if (&command($Link_Command, "-o", $executable, "$a_cc_name-$file.a.o", "$b_cc_name-$file.b.o",  "> $errfile 2>&1")) {
	print $Progress "*";
	if ($a_cc_name eq $Reference_CC_name) {
	    &register_error($b_cc, $file, "Link error when callee is linked with " .$a_cc_name . "'s caller");
	}
	else {
	    &register_error($a_cc, $file, "Link error when caller is linked with ". $b_cc_name . "'s callee");
	}
	$pass=0;
	if ($a_cc ne $b_cc) {
	    $Link_Command = $a_cc eq $Ref ? $b_cc : $a_cc;
	    print $Progress "L";
	    if (&command($Link_Command, "-o", $executable, "$a_cc_name-$file.a.o", "$b_cc_name-$file.b.o",  "> $errfile 2>&1")) {
		print $Progress "*";
	    }
	    else {
		$pass=1;
	    }
	}
    }

    if ($pass) {
#    else {

    # Check than an executable was generated...

	print $Progress "R";
	if ( -e $executable) {

	    # Run the executable. If an error is flagged, report it.

#	    $errfile = "$a_cc_name-$b_cc_name-$file.errors";
	    $errfile = "/dev/null";

	    if (&command($executable, "> $errfile 2>&1")) {
		print $Progress "*";
#		if ($a_cc_name eq $Reference_CC_name) {
#		    &register_error($b_cc, $file, "Callee does not run with $a_cc_name's caller");
#		}
#		else {
#		    &register_error($a_cc, $file, "Caller does not run with $b_cc_name's callee");
#		}
		$pass=0;
	    }
	}
	else {
	    print $Progress "*";
#	    if ($a_cc_name eq $Reference_CC_name) {
#		&register_error($b_cc, $file, "Linker generates no output file when callee is linked with $a_cc_name's caller");
#	    }
#	    else {
#		&register_error($a_cc, $file, "Linker generates no output file when caller is linked with $b_cc_name's callee");
#	    }
	    $pass=0;
	}
    }
    $pass;
}

####
#
# NAME:     generate_all_error_reports
#   
# PURPOSE:  Generates error reports for all compilers
#   
# ARGS:     filename - the name of the file to place error report
#   
# NOTES:    If a filename is not given, it is written to standard error
#   
####

sub generate_all_error_reports {
    local ($filename) = @_;
    local ($cc);

    # Open the file name

    if ($filename) {
	open(FD, ">$filename") || die "Couldn't open file $filename: $!\n";
	$fd = FD;
    }
    else {
	$fd = $Progress;
    }

    # Dump out the header

    print $fd "\nError Report\n";
    print $fd "============\n";
    print $fd "Compilers Tested: \n";

    # List the compilers that were tested.

    foreach $cc ($Ref, @Compilers) {
	print $fd "$cc\n";
    }

    print $fd "\nPassed: $Total_Tests_Passed\n";
    print $fd "Failed: $Total_Tests_Failed\n";
    print $fd "Total: $Total_Tests\n\n";

    # Generate the compiler-specific error report

    foreach $cc ($Ref, @Compilers) {
	&generate_error_report($cc, $fd);
    }
    
    print $fd "\nEnd of Error Report\n";
    if ($filename) {
	close $fd;
    }
}

####
# 
# NAME:     register-error
#   
# PURPOSE:  Register and error with a compiler for later reporting.
#   
# ARGS:     cc - the compiler the caused the error
#	    file - the base test name that caused the error
#	    error - text for the error that occurred.
#   
####

sub register_error {
    local ($cc, $file, $error) = @_;
    local (@errors);

    # Each element of the error report looks like:

    # cc:error;cc1:error1...

    if ($Compiler_Errors{$file}) {
	$Compiler_Errors{$file} = $Compiler_Errors{$file} . ";$cc:$error";
    }
    else {
	$Compiler_Errors{$file} = "$cc:$error";
    }

    # Increment the number of errors found for this compiler.

    $Compiler_Error_Counts{$cc}++;
}

####
# 
# NAME:     generate_error_report
#   
# PURPOSE:  Generates the error report for a compiler
#   
# ARGS:     cc - the compiler to report errors about
#           fd - the output file descriptor for the report
#   
####

sub generate_error_report {
    local ($cc, $fd) = @_;
    local ($file, $errors, $error, $compiler, %by_error);
    local (@files);

    # If there were no errors, don't do anything.

    if ($Compiler_Error_Counts{$cc} == 0) {
	return;
    }

    print $fd "Error report for compiler: $cc\n";
    print $fd "Total errors: $Compiler_Error_Counts{$cc}\n";

    # For each file, check its errors...

    while (($file, $errors) = each(%Compiler_Errors)) {
	
	# For each error, check if the compiler causing the error is this one.

	foreach $error (split(/;/, $errors)) {
	    ($compiler, $error) = split(/:/, $error);
	    if ($cc eq $compiler) {

		if ($by_error{$error}) {
		    $by_error{$error} .= ":$file";
		}
		else {
		    $by_error{$error} = $file;
		}
	    }
	}
    }

    while (($error, $files) = each(%by_error)) {
	print $fd "Tests having error `$error':\n";
	@file_list = sort(split(":", $files));
	foreach $file (@file_list) {
	    print $fd "\t$file\n";
	}
	print $fd "\n";
    }
    
    print $fd "\n";
}

####
# 
# NAME:     command
#   
# PURPOSE:  runs a program. Useful stub for printing what is happening.
#   
#   
####

sub command {
    local(@cmd) = @_;
    
    if ($opt_n) {
	print "@cmd\n";
	return 0;
    }
    else {
	system("@cmd");		# This needs to be placed in quotes so shell
    				# processing occurs.
    }
}

####
# 
# NAME:     basename
#   
# PURPOSE:  computes the basename for a file, like the shell basename
#   
# ARGS:     a string containing /.../.../.../name ...
#   
# RETURNS:  name
#   
####

sub basename {
    local ($command) = @_;

    $command =~ s/\s.*//;	# strip off everything after a space
    $command =~ s#.*/##;	# strip off everything before including the "/";
    $command;
}

####
# 
# NAME:     redirect_output
#   
# PURPOSE:  Redirected standard output and standard error to a different place.
#	    Equivalent of 1> file 2>&1 in shell.
#   
# ARGS:     fd - filedescriptor to use.
#   
####

sub redirect_output {
    local($fd) = @_;

    close STDOUT || die "Couldn't close standard out: $!\n";
    open(STDOUT, ">&$fd") || die "Couldn't dup standard out: $!\n";
    close STDERR || die "Couldn't close standard error: $!\n";
    open(STDERR, ">&$fd") || die "Couldn't dup standard error: $!\n";
}

####
# 
# NAME:     unique_name
#   
# PURPOSE:  Returns a unique filename with given prefix. Guaranteed to not
#	    exist.
#   
# ARGS:     filename prefix
#   
# RETURNS:  unique filename
#   
####

sub unique_name {
    local ($prefix) = @_;
    local ($count, $filename);

    $count = 1;
    $filename = $prefix;
    while ( -e $filename) {
	$filename = "$prefix.$count";
	$count++;
    }	

    $filename;
}

####
# 
# NAME:     rw_popen
#   
# PURPOSE:  Open a pipe for read/write access.
#   
# ARGS:     program - program to run on other end of pipe.
#   
# RETURNS:  in - fd to read from to get output from program
#           out - fd to write to to give input to program
#   
####

sub rw_popen {
    local(@program) = @_;
    local ($pid, $oldfh);

    pipe(CHILD_READ, PARENT_WRITE) || die "Couldn't open child read pipe: $!\n";
    pipe(PARENT_READ, CHILD_WRITE) || die "Couldn't open child write pipe: $!\n";

    # Select unbuffered i/o for all ends of the pipes.

    $oldfh = select(PARENT_READ); $| = 1;
    select(PARENT_WRITE); $| = 1;
    select(CHILD_READ); $| = 1;
    select(CHILD_WRITE); $| = 1;
    select($oldfh);

    if ($pid = fork) { # parent
	close CHILD_READ || die "Couldn't close child read pipe: $!\n";
	close CHILD_WRITE || die "Couldn't close child write pipe: $!\n";
    } elsif (defined $pid) { # child
	
	# attach the child's end of the pipes to stdin and stdout

	# close stdin -- leaves fd 0 for dup
	# dup read pipe, grabbing fd 0

	close STDIN || die "Couldn't close child's standard output: $!\n";
	open(STDIN, ">&CHILD_READ") ||
	    die "Couldn't dup child's write pipe: $!\n";

	# close stdout -- leaves fd 1 for dup
	# dup write pipe, grabbing fd 1

	close STDOUT || die "Couldn't close child's standard output: $!\n";
	open(STDOUT, ">&CHILD_WRITE") ||
	    die "Couldn't dup child's write pipe: $!\n";

	# Close the child's end because they are now linked to stdin/stdout

	close CHILD_READ || die "Child couldn't close child read pipe: $!\n";
	close CHILD_WRITE || die "Child couldn't close child write pipe: $!\n";

	# close the parent's end since this is the child.

	close PARENT_READ || die "Couldn't close parent read pipe: $!\n";
	close PARENT_WRITE || die "Couldn't close parent write pipe: $!\n";

	exec (@program) || die "Couldn't exec $program: $!\n";
    }
    else {
	die "Can't fork: $!\n";
    }    

    # return the parent's read and write end of both pipes.

    (PARENT_READ, PARENT_WRITE);
}

